#!/usr/bin/python
#QQDown -- An open-sourced implementation of tencent offline download
#Copyright (C) 2011-2012 Tydus <Tydus@Tydus.org>
#
#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

# QQDownload CLI program

import qqdown
import sys
from qqweb import LoginError
from optparse import OptionParser
from re import match


USAGE_STR='''
%prog [options] operation [args]

Operations:
    list,ls
        Get a List of download files

    list_hash,lh
        Get a List of download files

    add <url> [<filename>]
        Add a url for downloading

    add_bt <filename>
        Add a bt task from local torrent

    add_bt_url <url>
        Download torrent from url and add it

    remove,rm <task_id> [<task_id>...]
        Del tasks

    get_http <hash>
        Get HTTP Download address and Cookie'''

opt_verbosity=None

def prompt(*args):
    if opt_verbosity!=False:
        for i in args:
            print i,
        print

def verbose(*args):
    if opt_verbosity==True:
        for i in args:
            print i,
        print

def dot(x,l):
    x=x.split('\\')[-1]
    if len(x)<l:
        return x
    d=(l-3)/2
    return x[:d]+'...'+x[-d:]

def print_table(format_str,prompt,functions,data):
    print format_str%(prompt)
    print format_str%tuple(['-'*80]*len(prompt))
    for i in data:
        print format_str%tuple(map(lambda x:x(i),functions))

def lst(args):
    res=d.get_task_list()
    verbose(res)
    print_table("%70.70s %4.4s %3.3s",
            ('filename','%','day'),
            (
                lambda i: dot(i['file_name'],50),
                lambda i: 100 if i['file_size']=='0' else (100*int(i['comp_size'])/int(i['file_size'])),
                lambda i: int(i['left_time'])/86400,
            ),
            res)

def lst_hash(args):
    res=d.get_task_list()
    verbose(res)
    print_table("%38.38s %40.40s",
            ('filename','hash'),
            (lambda i:dot(i['file_name'],58), lambda i:i.get('hash')),
            res)

def add(args):
    if len(args)!=1:
        raise ArgumentError("expect one url")
    verbose(d.add_task(args[0]))
    prompt("%s added"%args[0])

def add_bt(args):
    if len(args)!=1:
        raise ArgumentError("expect one filename")
    verbose(d.add_torrent(qqdown.get_torrent_from_file(args[0])))
    prompt("torrent from %s added"%args[0])

def add_bt_url(args):
    if len(args)!=1:
        raise ArgumentError("expect one url")
    verbose(d.add_torrent(qqdown.get_torrent_from_url(args[0])))
    prompt("torrent from %s downloaded and added"%args[0])

def remove(args):
    if len(args)==0:
        raise ArgumentError("expect task ids")
    verbose(d.del_task(args))
    prompt("%s Removed"%','.join(args))

def get_http(args):
    if len(args)!=1 or not match(r'^[0-9A-F]{40}$',args[0]):
        raise ArgumentError("expect only one hash")
    ret=d.get_http_url(args[0])
    print "URL: %s"%ret['url']
    print "Cookie: %s"%ret['cookie']

l_oper=dict(
        ls=lst,
        list=lst,
        list_hash=lst_hash,
        lh=lst_hash,
        add=add,
        add_bt=add_bt,
        add_bt_url=add_bt_url,
        rm=remove,
        remove=remove,
        get_http=get_http,
    )

class ArgumentError(Exception): pass

d=None

def main():
    global d,opt_verbosity

    op=OptionParser(usage=USAGE_STR)
    op.add_option('-c','--cookie',dest='cookie',help='cookie file')
    op.add_option('-u','--user',dest='user',help='username')
    op.add_option('-p','--pass',dest='password',help='password')
    op.add_option('-P','--pass-md53',action='store_true',help='password hash using md5_3')
    op.add_option('-q','--quiet',dest='verbosity',action='store_false',help='be quiet')
    op.add_option('-v','--verbose',dest='verbosity',action='store_true',help='be verbose')
    opt,arg=op.parse_args()
    opt_verbosity=opt.verbosity

    def fail(err):
        print "Error: %s"%err
        op.print_help()
        exit(-1)

    if(len(arg))==0:
        fail("no operation")

    try:
        if not opt.cookie:
            raise IOError()
        file(opt.cookie).close()
        d=qqdown.QQDown('','',nologin=True)
        d.load_cookie(opt.cookie)

    except IOError:
        while d==None:
            try:
                if not opt.user:
                    fail("no username")
                if not opt.password:
                    fail("no password")
                d=qqdown.QQDown(opt.user,opt.password,opt.pass_md53)
            except LoginError,e:
                print e.message[1]
                d=None

    if opt.cookie:
        d.save_cookie(opt.cookie)

    try:
        l_oper[arg[0]](arg[1:])
    except KeyError:
        fail("no such operation")
    except ArgumentError,e:
        fail(e.message)
    except Exception,e:
        print e.message
        exit(-1)


if __name__=="__main__":
    main()
